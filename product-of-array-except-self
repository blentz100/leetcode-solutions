//https://leetcode.com/problems/product-of-array-except-self/
//Solution is accepted, but it's relatively slow


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
  let solutionArr = []
  const leftProducts = []
  const rightProducts = []

  for(let i = 0, j = nums.length  -1; i < nums.length; i++, j--){
    leftProducts[i] = isNaN(leftProducts[i-1] * nums[i]) ? nums[i] : leftProducts[i-1] * nums[i]
    rightProducts[j] = isNaN(rightProducts[j + 1] * nums[j]) ? nums[j] : rightProducts[j + 1] * nums[j]    
  }
  for (let i = 0; i < nums.length; i++){
    solutionArr[i] = (isNaN(leftProducts[i-1]) ? 1 :leftProducts[i-1] )  
    * (isNaN(rightProducts[i+1]) ? 1 : rightProducts[i+1] )
  }
  return solutionArr
}


// Another Basic solution done on 1/5/2026
// 42ms, beats 6.24%

/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    // calculate 2 arrays: a prefix array and a postfix array
    const prefix = []
    const postfix = []
    const answer = [];

    for (let i = 0; i < nums.length; i++){
      prefix[i] = (nums[i - 1] ?? 1)  * (prefix[i - 1] ?? 1)
    }

    for (let j = nums.length -1; j >= 0; j--){
      postfix[j] = (nums[j + 1] ?? 1)  * (postfix[j + 1] ?? 1)
    }

    // then combine them to get the final answer

    for(let k = 0; k < nums.length; k++){
      answer[k] = prefix[k] * postfix[k]
    }
  
    return answer;
};
